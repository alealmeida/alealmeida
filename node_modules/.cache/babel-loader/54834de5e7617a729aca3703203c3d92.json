{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.acorn = global.acorn || {});\n})(this, function (exports) {\n  'use strict'; // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    7: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\" // And the keywords\n\n  };\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    6: ecma5AndLessKeywords + \" const class extends export import super\" // ## Character categories\n    // Big ugly regular expressions that match characters in the\n    // whitespace, identifier, and identifier-start categories. These\n    // are only applied when a character is found to actually have a\n    // code point above 128.\n    // Generated by `bin/generate-identifier-regex.js`.\n\n  };\n  var nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n  var nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA900-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];\n  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) return false;\n      pos += set[i + 1];\n      if (pos >= code) return true;\n    }\n  } // Test whether a given character code starts an identifier.\n\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return isInAstralSet(code, astralIdentifierStartCodes);\n  } // Test whether a given character is part of an identifier.\n\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n  } // ## Token types\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n\n  var TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {\n      beforeExpr: true,\n      binop: prec\n    });\n  }\n\n  var beforeExpr = {\n    beforeExpr: true\n  };\n  var startsExpr = {\n    startsExpr: true\n  }; // Map keyword names to token types.\n\n  var keywordTypes = {}; // Succinct definitions of keyword token types\n\n  function kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywordTypes[name] = new TokenType(name, options);\n  }\n\n  var tt = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n      prefix: true,\n      postfix: true,\n      startsExpr: true\n    }),\n    prefix: new TokenType(\"prefix\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=\", 6),\n    relational: binop(\"</>\", 7),\n    bitShift: binop(\"<</>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n      beforeExpr: true,\n      binop: 9,\n      prefix: true,\n      startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n      beforeExpr: true\n    }),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n      isLoop: true,\n      beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n      isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n      isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\"),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\"),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _void: kw(\"void\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }) // Matches a whole line break (where CRLF is considered a single\n    // line break). Used to count lines.\n\n  };\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  } // Checks if an object has a property.\n\n\n  function has(obj, propName) {\n    return Object.prototype.hasOwnProperty.call(obj, propName);\n  } // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) this.source = p.sourceFile;\n  }; // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur);\n      }\n    }\n  } // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3, or 5, or 6. This influences support for strict\n    // mode, the set of reserved words, support for getters and\n    // setters and other features. The default is 6.\n    ecmaVersion: 6,\n    // Source type (\"script\" or \"module\") for different semantics\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // th position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false,\n    plugins: {} // Interpret and default an options object\n\n  };\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions) {\n      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n    }\n\n    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n\n      options.onToken = function (token) {\n        return tokens.push(token);\n      };\n    }\n\n    if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);\n    return options;\n  }\n\n  function pushComment(options, array) {\n    return function (block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? 'Block' : 'Line',\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);\n      if (options.ranges) comment.range = [start, end];\n      array.push(comment);\n    };\n  } // Registered plugins\n\n\n  var plugins = {};\n\n  function keywordRegexp(words) {\n    return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\");\n  }\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n    var reserved = options.allowReserved ? \"\" : reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\");\n    this.reservedWords = keywordRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input); // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n\n    this.containsEsc = false; // Load plugins\n\n    this.loadPlugins(options.plugins); // Set up token state\n    // The current position of the tokenizer in the input.\n\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos));\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    } // Properties of the current token:\n    // Its type\n\n\n    this.type = tt.eof; // For tokens that include more information than their type, the value\n\n    this.value = null; // Its start and end offset\n\n    this.start = this.end = this.pos; // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n\n    this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n\n    this.context = this.initialContext();\n    this.exprAllowed = true; // Figure out if it's a module code.\n\n    this.strict = this.inModule = options.sourceType === \"module\"; // Used to signify the start of a potential arrow function\n\n    this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator.\n\n    this.inFunction = this.inGenerator = false; // Labels in scope.\n\n    this.labels = []; // If enabled, skip leading hashbang line.\n\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);\n  }; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n\n\n  Parser.prototype.isKeyword = function isKeyword(word) {\n    return this.keywords.test(word);\n  };\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    return this.reservedWords.test(word);\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n    var this$1 = this;\n\n    for (var name in pluginConfigs) {\n      var plugin = plugins[name];\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\");\n      plugin(this$1, pluginConfigs[name]);\n    }\n  };\n\n  Parser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n  };\n\n  var pp = Parser.prototype; // ## Parser utilities\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  pp.isUseStrict = function (stmt) {\n    return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.raw.slice(1, -1) === \"use strict\";\n  }; // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n\n  pp.eat = function (type) {\n    if (this.type === type) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }; // Tests whether parsed token is a contextual keyword.\n\n\n  pp.isContextual = function (name) {\n    return this.type === tt.name && this.value === name;\n  }; // Consumes contextual keyword if possible.\n\n\n  pp.eatContextual = function (name) {\n    return this.value === name && this.eat(tt.name);\n  }; // Asserts that following token is given contextual keyword.\n\n\n  pp.expectContextual = function (name) {\n    if (!this.eatContextual(name)) this.unexpected();\n  }; // Test whether a semicolon can be inserted at the current position.\n\n\n  pp.canInsertSemicolon = function () {\n    return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  };\n\n  pp.insertSemicolon = function () {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n      return true;\n    }\n  }; // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n\n  pp.semicolon = function () {\n    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();\n  };\n\n  pp.afterTrailingComma = function (tokType) {\n    if (this.type == tokType) {\n      if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n      this.next();\n      return true;\n    }\n  }; // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n\n  pp.expect = function (type) {\n    this.eat(type) || this.unexpected();\n  }; // Raise an unexpected token error.\n\n\n  pp.unexpected = function (pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  var DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = 0;\n    this.trailingComma = 0;\n  };\n\n  pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {\n    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma;\n    if (!andThrow) return !!trailing;\n    if (trailing) this.raise(trailing, \"Comma is not permitted after the rest element\");\n  };\n\n  pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;\n    if (!andThrow) return !!pos;\n    if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\");\n  };\n\n  var pp$1 = Parser.prototype; // ### Statement parsing\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function (node) {\n    var this$1 = this;\n    var first = true;\n    if (!node.body) node.body = [];\n\n    while (this.type !== tt.eof) {\n      var stmt = this$1.parseStatement(true, true);\n      node.body.push(stmt);\n\n      if (first) {\n        if (this$1.isUseStrict(stmt)) this$1.setStrict(true);\n        first = false;\n      }\n    }\n\n    this.next();\n\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n\n    return this.finishNode(node, \"Program\");\n  };\n\n  var loopLabel = {\n    kind: \"loop\"\n  };\n  var switchLabel = {\n    kind: \"switch\"\n  };\n\n  pp$1.isLet = function () {\n    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false;\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length,\n        nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91 || nextCh == 123) return true; // '{' and '['\n\n    if (isIdentifierStart(nextCh, true)) {\n      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n\n      var ident = this.input.slice(next, pos);\n      if (!this.isKeyword(ident)) return true;\n    }\n\n    return false;\n  }; // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n\n  pp$1.parseStatement = function (declaration, topLevel) {\n    var starttype = this.type,\n        node = this.startNode(),\n        kind;\n\n    if (this.isLet()) {\n      starttype = tt._var;\n      kind = \"let\";\n    } // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n\n    switch (starttype) {\n      case tt._break:\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case tt._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case tt._do:\n        return this.parseDoStatement(node);\n\n      case tt._for:\n        return this.parseForStatement(node);\n\n      case tt._function:\n        if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();\n        return this.parseFunctionStatement(node);\n\n      case tt._class:\n        if (!declaration) this.unexpected();\n        return this.parseClass(node, true);\n\n      case tt._if:\n        return this.parseIfStatement(node);\n\n      case tt._return:\n        return this.parseReturnStatement(node);\n\n      case tt._switch:\n        return this.parseSwitchStatement(node);\n\n      case tt._throw:\n        return this.parseThrowStatement(node);\n\n      case tt._try:\n        return this.parseTryStatement(node);\n\n      case tt._const:\n      case tt._var:\n        kind = kind || this.value;\n        if (!declaration && kind != \"var\") this.unexpected();\n        return this.parseVarStatement(node, kind);\n\n      case tt._while:\n        return this.parseWhileStatement(node);\n\n      case tt._with:\n        return this.parseWithStatement(node);\n\n      case tt.braceL:\n        return this.parseBlock();\n\n      case tt.semi:\n        return this.parseEmptyStatement(node);\n\n      case tt._export:\n      case tt._import:\n        if (!this.options.allowImportExportEverywhere) {\n          if (!topLevel) this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n          if (!this.inModule) this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n\n        return starttype === tt._import ? this.parseImport(node) : this.parseExport(node);\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n      default:\n        var maybeName = this.value,\n            expr = this.parseExpression();\n        if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function (node, keyword) {\n    var this$1 = this;\n    var isBreak = keyword == \"break\";\n    this.next();\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    } // Verify that there is an actual destination to break or\n    // continue to.\n\n    for (var i = 0; i < this.labels.length; ++i) {\n      var lab = this$1.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  };\n\n  pp$1.parseDebuggerStatement = function (node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  };\n\n  pp$1.parseDoStatement = function (node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    this.expect(tt._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();\n    return this.finishNode(node, \"DoWhileStatement\");\n  }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n\n  pp$1.parseForStatement = function (node) {\n    this.next();\n    this.labels.push(loopLabel);\n    this.expect(tt.parenL);\n    if (this.type === tt.semi) return this.parseFor(node, null);\n    var isLet = this.isLet();\n\n    if (this.type === tt._var || this.type === tt._const || isLet) {\n      var init$1 = this.startNode(),\n          kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1 && !(kind !== \"var\" && init$1.declarations[0].init)) return this.parseForIn(node, init$1);\n      return this.parseFor(node, init$1);\n    }\n\n    var refDestructuringErrors = new DestructuringErrors();\n    var init = this.parseExpression(true, refDestructuringErrors);\n\n    if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n      this.checkPatternErrors(refDestructuringErrors, true);\n      this.toAssignable(init);\n      this.checkLVal(init);\n      return this.parseForIn(node, init);\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n\n    return this.parseFor(node, init);\n  };\n\n  pp$1.parseFunctionStatement = function (node) {\n    this.next();\n    return this.parseFunction(node, true);\n  };\n\n  pp$1.parseIfStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    node.consequent = this.parseStatement(false);\n    node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null;\n    return this.finishNode(node, \"IfStatement\");\n  };\n\n  pp$1.parseReturnStatement = function (node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, \"'return' outside of function\");\n    this.next(); // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  };\n\n  pp$1.parseSwitchStatement = function (node) {\n    var this$1 = this;\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(tt.braceL);\n    this.labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    for (var cur, sawDefault = false; this.type != tt.braceR;) {\n      if (this$1.type === tt._case || this$1.type === tt._default) {\n        var isCase = this$1.type === tt._case;\n        if (cur) this$1.finishNode(cur, \"SwitchCase\");\n        node.cases.push(cur = this$1.startNode());\n        cur.consequent = [];\n        this$1.next();\n\n        if (isCase) {\n          cur.test = this$1.parseExpression();\n        } else {\n          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\");\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this$1.expect(tt.colon);\n      } else {\n        if (!cur) this$1.unexpected();\n        cur.consequent.push(this$1.parseStatement(true));\n      }\n    }\n\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  };\n\n  pp$1.parseThrowStatement = function (node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }; // Reused empty array added for node fields that are always empty.\n\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function (node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.type === tt._catch) {\n      var clause = this.startNode();\n      this.next();\n      this.expect(tt.parenL);\n      clause.param = this.parseBindingAtom();\n      this.checkLVal(clause.param, true);\n      this.expect(tt.parenR);\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) this.raise(node.start, \"Missing catch or finally clause\");\n    return this.finishNode(node, \"TryStatement\");\n  };\n\n  pp$1.parseVarStatement = function (node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  pp$1.parseWhileStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  };\n\n  pp$1.parseWithStatement = function (node) {\n    if (this.strict) this.raise(this.start, \"'with' in strict mode\");\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(false);\n    return this.finishNode(node, \"WithStatement\");\n  };\n\n  pp$1.parseEmptyStatement = function (node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  };\n\n  pp$1.parseLabeledStatement = function (node, maybeName, expr) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.labels.length; ++i) {\n      if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n\n    var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null;\n\n    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n      var label = this$1.labels[i$1];\n\n      if (label.statementStart == node.start) {\n        label.statementStart = this$1.start;\n        label.kind = kind;\n      } else break;\n    }\n\n    this.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.start\n    });\n    node.body = this.parseStatement(true);\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  };\n\n  pp$1.parseExpressionStatement = function (node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }; // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n\n  pp$1.parseBlock = function (allowStrict) {\n    var this$1 = this;\n    var node = this.startNode(),\n        first = true,\n        oldStrict;\n    node.body = [];\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      var stmt = this$1.parseStatement(true);\n      node.body.push(stmt);\n\n      if (first && allowStrict && this$1.isUseStrict(stmt)) {\n        oldStrict = this$1.strict;\n        this$1.setStrict(this$1.strict = true);\n      }\n\n      first = false;\n    }\n\n    if (oldStrict === false) this.setStrict(false);\n    return this.finishNode(node, \"BlockStatement\");\n  }; // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n\n  pp$1.parseFor = function (node, init) {\n    node.init = init;\n    this.expect(tt.semi);\n    node.test = this.type === tt.semi ? null : this.parseExpression();\n    this.expect(tt.semi);\n    node.update = this.type === tt.parenR ? null : this.parseExpression();\n    this.expect(tt.parenR);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n\n  pp$1.parseForIn = function (node, init) {\n    var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.expect(tt.parenR);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, type);\n  }; // Parse a list of variable declarations.\n\n\n  pp$1.parseVar = function (node, isFor, kind) {\n    var this$1 = this;\n    node.declarations = [];\n    node.kind = kind;\n\n    for (;;) {\n      var decl = this$1.startNode();\n      this$1.parseVarId(decl);\n\n      if (this$1.eat(tt.eq)) {\n        decl.init = this$1.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this$1.type === tt._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\"))) {\n        this$1.unexpected();\n      } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n      if (!this$1.eat(tt.comma)) break;\n    }\n\n    return node;\n  };\n\n  pp$1.parseVarId = function (decl) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, true);\n  }; // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseFunction = function (node, isStatement, allowExpressionBody) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) node.generator = this.eat(tt.star);\n    var oldInGen = this.inGenerator;\n    this.inGenerator = node.generator;\n    if (isStatement || this.type === tt.name) node.id = this.parseIdent();\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody);\n    this.inGenerator = oldInGen;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  };\n\n  pp$1.parseFunctionParams = function (node) {\n    this.expect(tt.parenL);\n    node.params = this.parseBindingList(tt.parenR, false, false, true);\n  }; // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseClass = function (node, isStatement) {\n    var this$1 = this;\n    this.next();\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (this$1.eat(tt.semi)) continue;\n      var method = this$1.startNode();\n      var isGenerator = this$1.eat(tt.star);\n      var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\";\n      this$1.parsePropertyName(method);\n      method.static = isMaybeStatic && this$1.type !== tt.parenL;\n\n      if (method.static) {\n        if (isGenerator) this$1.unexpected();\n        isGenerator = this$1.eat(tt.star);\n        this$1.parsePropertyName(method);\n      }\n\n      method.kind = \"method\";\n      var isGetSet = false;\n\n      if (!method.computed) {\n        var key = method.key;\n\n        if (!isGenerator && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n          isGetSet = true;\n          method.kind = key.name;\n          key = this$1.parsePropertyName(method);\n        }\n\n        if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n          if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\");\n          if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\");\n          if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\");\n          method.kind = \"constructor\";\n          hadConstructor = true;\n        }\n      }\n\n      this$1.parseClassMethod(classBody, method, isGenerator);\n\n      if (isGetSet) {\n        var paramCount = method.kind === \"get\" ? 0 : 1;\n\n        if (method.value.params.length !== paramCount) {\n          var start = method.value.start;\n          if (method.kind === \"get\") this$1.raiseRecoverable(start, \"getter should have no params\");else this$1.raiseRecoverable(start, \"setter should have exactly one param\");\n        }\n\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") this$1.raise(method.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    }\n\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  pp$1.parseClassMethod = function (classBody, method, isGenerator) {\n    method.value = this.parseMethod(isGenerator);\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n  };\n\n  pp$1.parseClassId = function (node, isStatement) {\n    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;\n  };\n\n  pp$1.parseClassSuper = function (node) {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }; // Parses module export declaration.\n\n\n  pp$1.parseExport = function (node) {\n    var this$1 = this;\n    this.next(); // export * from '...'\n\n    if (this.eat(tt.star)) {\n      this.expectContextual(\"from\");\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      // export default ...\n      var parens = this.type == tt.parenL;\n      var expr = this.parseMaybeAssign();\n      var needsSemi = true;\n\n      if (!parens && (expr.type == \"FunctionExpression\" || expr.type == \"ClassExpression\")) {\n        needsSemi = false;\n\n        if (expr.id) {\n          expr.type = expr.type == \"FunctionExpression\" ? \"FunctionDeclaration\" : \"ClassDeclaration\";\n        }\n      }\n\n      node.declaration = expr;\n      if (needsSemi) this.semicolon();\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    } // export var|const|let|function|class ...\n\n\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(true);\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers();\n\n      if (this.eatContextual(\"from\")) {\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      } else {\n        // check for keywords used as local names\n        for (var i = 0; i < node.specifiers.length; i++) {\n          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n            this$1.unexpected(node.specifiers[i].local.start);\n          }\n        }\n\n        node.source = null;\n      }\n\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  };\n\n  pp$1.shouldParseExportStatement = function () {\n    return this.type.keyword || this.isLet();\n  }; // Parses a comma-separated list of module exports.\n\n\n  pp$1.parseExportSpecifiers = function () {\n    var this$1 = this;\n    var nodes = [],\n        first = true; // export { x, y as z } [from '...']\n\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var node = this$1.startNode();\n      node.local = this$1.parseIdent(this$1.type === tt._default);\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }; // Parses import declaration.\n\n\n  pp$1.parseImport = function (node) {\n    this.next(); // import '...'\n\n    if (this.type === tt.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }; // Parses a comma-separated list of module imports.\n\n\n  pp$1.parseImportSpecifiers = function () {\n    var this$1 = this;\n    var nodes = [],\n        first = true;\n\n    if (this.type === tt.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, true);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(tt.comma)) return nodes;\n    }\n\n    if (this.type === tt.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, true);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes;\n    }\n\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var node$2 = this$1.startNode();\n      node$2.imported = this$1.parseIdent(true);\n\n      if (this$1.eatContextual(\"as\")) {\n        node$2.local = this$1.parseIdent();\n      } else {\n        node$2.local = node$2.imported;\n        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start);\n        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raise(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\");\n      }\n\n      this$1.checkLVal(node$2.local, true);\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n    }\n\n    return nodes;\n  };\n\n  var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function (node, isBinding) {\n    var this$1 = this;\n\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          for (var i = 0; i < node.properties.length; i++) {\n            var prop = node.properties[i];\n            if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n            this$1.toAssignable(prop.value, isBinding);\n          }\n\n          break;\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n          this.toAssignableList(node.elements, isBinding);\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            node.type = \"AssignmentPattern\";\n            delete node.operator; // falls through to AssignmentPattern\n          } else {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n            break;\n          }\n\n        case \"AssignmentPattern\":\n          if (node.right.type === \"YieldExpression\") this.raise(node.right.start, \"Yield expression cannot be a default value\");\n          break;\n\n        case \"ParenthesizedExpression\":\n          node.expression = this.toAssignable(node.expression, isBinding);\n          break;\n\n        case \"MemberExpression\":\n          if (!isBinding) break;\n\n        default:\n          this.raise(node.start, \"Assigning to rvalue\");\n      }\n    }\n\n    return node;\n  }; // Convert list of expression atoms to binding list.\n\n\n  pp$2.toAssignableList = function (exprList, isBinding) {\n    var this$1 = this;\n    var end = exprList.length;\n\n    if (end) {\n      var last = exprList[end - 1];\n\n      if (last && last.type == \"RestElement\") {\n        --end;\n      } else if (last && last.type == \"SpreadElement\") {\n        last.type = \"RestElement\";\n        var arg = last.argument;\n        this.toAssignable(arg, isBinding);\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") this.unexpected(arg.start);\n        --end;\n      }\n\n      if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") this.unexpected(last.argument.start);\n    }\n\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) this$1.toAssignable(elt, isBinding);\n    }\n\n    return exprList;\n  }; // Parses spread element.\n\n\n  pp$2.parseSpread = function (refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n  };\n\n  pp$2.parseRest = function (allowNonIdent) {\n    var node = this.startNode();\n    this.next(); // RestElement inside of a function parameter must be an identifier\n\n    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();\n    return this.finishNode(node, \"RestElement\");\n  }; // Parses lvalue (assignable) atom.\n\n\n  pp$2.parseBindingAtom = function () {\n    if (this.options.ecmaVersion < 6) return this.parseIdent();\n\n    switch (this.type) {\n      case tt.name:\n        return this.parseIdent();\n\n      case tt.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(tt.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\");\n\n      case tt.braceL:\n        return this.parseObj(true);\n\n      default:\n        this.unexpected();\n    }\n  };\n\n  pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (first) first = false;else this$1.expect(tt.comma);\n\n      if (allowEmpty && this$1.type === tt.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break;\n      } else if (this$1.type === tt.ellipsis) {\n        var rest = this$1.parseRest(allowNonIdent);\n        this$1.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n        this$1.expect(close);\n        break;\n      } else {\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n        this$1.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n\n    return elts;\n  };\n\n  pp$2.parseBindingListItem = function (param) {\n    return param;\n  }; // Parses assignment pattern around given atom if possible.\n\n\n  pp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }; // Verify that a node is an lval — something that can be assigned\n  // to.\n\n\n  pp$2.checkLVal = function (expr, isBinding, checkClashes) {\n    var this$1 = this;\n\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n\n        if (checkClashes) {\n          if (has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, \"Argument name clash\");\n          checkClashes[expr.name] = true;\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n        break;\n\n      case \"ObjectPattern\":\n        for (var i = 0; i < expr.properties.length; i++) {\n          this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n          var elem = expr.elements[i$1];\n          if (elem) this$1.checkLVal(elem, isBinding, checkClashes);\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, isBinding, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, isBinding, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, isBinding, checkClashes);\n        break;\n\n      default:\n        this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  var pp$3 = Parser.prototype; // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function (prop, propHash) {\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;\n    var key = prop.key;\n    var name;\n\n    switch (key.type) {\n      case \"Identifier\":\n        name = key.name;\n        break;\n\n      case \"Literal\":\n        name = String(key.value);\n        break;\n\n      default:\n        return;\n    }\n\n    var kind = prop.kind;\n\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        propHash.proto = true;\n      }\n\n      return;\n    }\n\n    name = \"$\" + name;\n    var other = propHash[name];\n\n    if (other) {\n      var isGetSet = kind !== \"init\";\n      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, \"Redefinition of property\");\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n\n    other[kind] = true;\n  }; // ### Expression parsing\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n\n  pp$3.parseExpression = function (noIn, refDestructuringErrors) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\n    if (this.type === tt.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));\n      }\n\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }; // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n\n  pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield();\n    var ownDestructuringErrors = false;\n\n    if (!refDestructuringErrors) {\n      refDestructuringErrors = new DestructuringErrors();\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    if (this.type == tt.parenL || this.type == tt.name) this.potentialArrowAt = this.start;\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n\n    if (this.type.isAssign) {\n      this.checkPatternErrors(refDestructuringErrors, true);\n      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors);\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === tt.eq ? this.toAssignable(left) : left;\n      refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly\n\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n\n    return left;\n  }; // Parse a ternary conditional (`?:`) operator.\n\n\n  pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n\n    if (this.eat(tt.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }; // Start the precedence parser.\n\n\n  pp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }; // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n\n  pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n\n    if (prec != null && (!noIn || this.type !== tt._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  };\n\n  pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n  }; // Parse unary operators, both prefix and postfix.\n\n\n  pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        expr;\n\n    if (this.type.prefix) {\n      var node = this.startNode(),\n          update = this.type === tt.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");else sawUnary = true;\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.operator = this$1.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this$1.checkLVal(expr);\n        this$1.next();\n        expr = this$1.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(tt.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);else return expr;\n  }; // Parse call, dot, and `[]`-subscript expressions.\n\n\n  pp$3.parseExprSubscripts = function (refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;\n    return this.parseSubscripts(expr, startPos, startLoc);\n  };\n\n  pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n    var this$1 = this;\n\n    for (;;) {\n      if (this$1.eat(tt.dot)) {\n        var node = this$1.startNodeAt(startPos, startLoc);\n        node.object = base;\n        node.property = this$1.parseIdent(true);\n        node.computed = false;\n        base = this$1.finishNode(node, \"MemberExpression\");\n      } else if (this$1.eat(tt.bracketL)) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.object = base;\n        node$1.property = this$1.parseExpression();\n        node$1.computed = true;\n        this$1.expect(tt.bracketR);\n        base = this$1.finishNode(node$1, \"MemberExpression\");\n      } else if (!noCalls && this$1.eat(tt.parenL)) {\n        var node$2 = this$1.startNodeAt(startPos, startLoc);\n        node$2.callee = base;\n        node$2.arguments = this$1.parseExprList(tt.parenR, false);\n        base = this$1.finishNode(node$2, \"CallExpression\");\n      } else if (this$1.type === tt.backQuote) {\n        var node$3 = this$1.startNodeAt(startPos, startLoc);\n        node$3.tag = base;\n        node$3.quasi = this$1.parseTemplate();\n        base = this$1.finishNode(node$3, \"TaggedTemplateExpression\");\n      } else {\n        return base;\n      }\n    }\n  }; // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n\n  pp$3.parseExprAtom = function (refDestructuringErrors) {\n    var node,\n        canBeArrow = this.potentialArrowAt == this.start;\n\n    switch (this.type) {\n      case tt._super:\n        if (!this.inFunction) this.raise(this.start, \"'super' outside of function or class\");\n\n      case tt._this:\n        var type = this.type === tt._this ? \"ThisExpression\" : \"Super\";\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, type);\n\n      case tt.name:\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var id = this.parseIdent(this.type !== tt.name);\n        if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);\n        return id;\n\n      case tt.regexp:\n        var value = this.value;\n        node = this.parseLiteral(value.value);\n        node.regex = {\n          pattern: value.pattern,\n          flags: value.flags\n        };\n        return node;\n\n      case tt.num:\n      case tt.string:\n        return this.parseLiteral(this.value);\n\n      case tt._null:\n      case tt._true:\n      case tt._false:\n        node = this.startNode();\n        node.value = this.type === tt._null ? null : this.type === tt._true;\n        node.raw = this.type.keyword;\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case tt.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case tt.bracketL:\n        node = this.startNode();\n        this.next();\n        node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case tt.braceL:\n        return this.parseObj(false, refDestructuringErrors);\n\n      case tt._function:\n        node = this.startNode();\n        this.next();\n        return this.parseFunction(node, false);\n\n      case tt._class:\n        return this.parseClass(this.startNode(), false);\n\n      case tt._new:\n        return this.parseNew();\n\n      case tt.backQuote:\n        return this.parseTemplate();\n\n      default:\n        this.unexpected();\n    }\n  };\n\n  pp$3.parseLiteral = function (value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    this.next();\n    return this.finishNode(node, \"Literal\");\n  };\n\n  pp$3.parseParenExpression = function () {\n    this.expect(tt.parenL);\n    var val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        val;\n\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n      var innerStartPos = this.start,\n          innerStartLoc = this.startLoc;\n      var exprList = [],\n          first = true;\n      var refDestructuringErrors = new DestructuringErrors(),\n          spreadStart,\n          innerParenStart;\n\n      while (this.type !== tt.parenR) {\n        first ? first = false : this$1.expect(tt.comma);\n\n        if (this$1.type === tt.ellipsis) {\n          spreadStart = this$1.start;\n          exprList.push(this$1.parseParenItem(this$1.parseRest()));\n          break;\n        } else {\n          if (this$1.type === tt.parenL && !innerParenStart) {\n            innerParenStart = this$1.start;\n          }\n\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n        }\n      }\n\n      var innerEndPos = this.start,\n          innerEndLoc = this.startLoc;\n      this.expect(tt.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, true);\n        if (innerParenStart) this.unexpected(innerParenStart);\n        return this.parseParenArrowList(startPos, startLoc, exprList);\n      }\n\n      if (!exprList.length) this.unexpected(this.lastTokStart);\n      if (spreadStart) this.unexpected(spreadStart);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n      return val;\n    }\n  };\n\n  pp$3.parseParenItem = function (item) {\n    return item;\n  };\n\n  pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n  }; // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function () {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n\n    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\") this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n      if (!this.inFunction) this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n      return this.finishNode(node, \"MetaProperty\");\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false);else node.arguments = empty$1;\n    return this.finishNode(node, \"NewExpression\");\n  }; // Parse template expression.\n\n\n  pp$3.parseTemplateElement = function () {\n    var elem = this.startNode();\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n      cooked: this.value\n    };\n    this.next();\n    elem.tail = this.type === tt.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  pp$3.parseTemplate = function () {\n    var this$1 = this;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this$1.expect(tt.dollarBraceL);\n      node.expressions.push(this$1.parseExpression());\n      this$1.expect(tt.braceR);\n      node.quasis.push(curElt = this$1.parseTemplateElement());\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }; // Parse an object literal or binding pattern.\n\n\n  pp$3.parseObj = function (isPattern, refDestructuringErrors) {\n    var this$1 = this;\n    var node = this.startNode(),\n        first = true,\n        propHash = {};\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var prop = this$1.startNode(),\n          isGenerator,\n          startPos,\n          startLoc;\n\n      if (this$1.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n\n        if (isPattern || refDestructuringErrors) {\n          startPos = this$1.start;\n          startLoc = this$1.startLoc;\n        }\n\n        if (!isPattern) isGenerator = this$1.eat(tt.star);\n      }\n\n      this$1.parsePropertyName(prop);\n      this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);\n      this$1.checkPropClash(prop, propHash);\n      node.properties.push(this$1.finishNode(prop, \"Property\"));\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  };\n\n  pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator);\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type != tt.comma && this.type != tt.braceR) {\n      if (isGenerator || isPattern) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") this.raiseRecoverable(start, \"getter should have no params\");else this.raiseRecoverable(start, \"setter should have exactly one param\");\n      }\n\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == \"yield\") this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\");\n      prop.kind = \"init\";\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === tt.eq && refDestructuringErrors) {\n        if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n\n      prop.shorthand = true;\n    } else this.unexpected();\n  };\n\n  pp$3.parsePropertyName = function (prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(tt.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(tt.bracketR);\n        return prop.key;\n      } else {\n        prop.computed = false;\n      }\n    }\n\n    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);\n  }; // Initialize empty function node.\n\n\n  pp$3.initFunction = function (node) {\n    node.id = null;\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n  }; // Parse object or class method.\n\n\n  pp$3.parseMethod = function (isGenerator) {\n    var node = this.startNode(),\n        oldInGen = this.inGenerator;\n    this.inGenerator = isGenerator;\n    this.initFunction(node);\n    this.expect(tt.parenL);\n    node.params = this.parseBindingList(tt.parenR, false, false);\n    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;\n    this.parseFunctionBody(node, false);\n    this.inGenerator = oldInGen;\n    return this.finishNode(node, \"FunctionExpression\");\n  }; // Parse arrow function expression with given parameters.\n\n\n  pp$3.parseArrowExpression = function (node, params) {\n    var oldInGen = this.inGenerator;\n    this.inGenerator = false;\n    this.initFunction(node);\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true);\n    this.inGenerator = oldInGen;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }; // Parse function body and check parameters.\n\n\n  pp$3.parseFunctionBody = function (node, isArrowFunction) {\n    var isExpression = isArrowFunction && this.type !== tt.braceL;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n    } else {\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldInFunc = this.inFunction,\n          oldLabels = this.labels;\n      this.inFunction = true;\n      this.labels = [];\n      node.body = this.parseBlock(true);\n      node.expression = false;\n      this.inFunction = oldInFunc;\n      this.labels = oldLabels;\n    } // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n\n\n    var useStrict = !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0]) ? node.body.body[0] : null;\n\n    if (this.strict || useStrict) {\n      var oldStrict = this.strict;\n      this.strict = true;\n      if (node.id) this.checkLVal(node.id, true);\n      this.checkParams(node, useStrict);\n      this.strict = oldStrict;\n    } else if (isArrowFunction) {\n      this.checkParams(node, useStrict);\n    }\n  }; // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n\n  pp$3.checkParams = function (node, useStrict) {\n    var this$1 = this;\n    var nameHash = {};\n\n    for (var i = 0; i < node.params.length; i++) {\n      if (useStrict && this$1.options.ecmaVersion >= 7 && node.params[i].type !== \"Identifier\") this$1.raiseRecoverable(useStrict.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      this$1.checkLVal(node.params[i], true, nameHash);\n    }\n  }; // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n\n  pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) break;\n      } else first = false;\n\n      var elt;\n      if (allowEmpty && this$1.type === tt.comma) elt = null;else if (this$1.type === tt.ellipsis) {\n        elt = this$1.parseSpread(refDestructuringErrors);\n\n        if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n          refDestructuringErrors.trailingComma = this$1.lastTokStart;\n        }\n      } else elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n      elts.push(elt);\n    }\n\n    return elts;\n  }; // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n\n  pp$3.parseIdent = function (liberal) {\n    var node = this.startNode();\n    if (liberal && this.options.allowReserved == \"never\") liberal = false;\n\n    if (this.type === tt.name) {\n      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)) this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\");\n      if (!liberal && this.inGenerator && this.value === \"yield\") this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\");\n      node.name = this.value;\n    } else if (liberal && this.type.keyword) {\n      node.name = this.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"Identifier\");\n  }; // Parses yield expression inside generator.\n\n\n  pp$3.parseYield = function () {\n    var node = this.startNode();\n    this.next();\n\n    if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(tt.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  };\n\n  var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function (pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function () {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart);\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) this.loc = new SourceLocation(parser, loc);\n    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;\n    if (parser.options.ranges) this.range = [pos, 0];\n  }; // Start an AST node, attaching a start offset.\n\n\n  var pp$5 = Parser.prototype;\n\n  pp$5.startNode = function () {\n    return new Node(this, this.start, this.startLoc);\n  };\n\n  pp$5.startNodeAt = function (pos, loc) {\n    return new Node(this, pos, loc);\n  }; // Finish an AST node, adding `type` and `end` properties.\n\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    return node;\n  }\n\n  pp$5.finishNode = function (node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n  }; // Finish node at given position\n\n\n  pp$5.finishNodeAt = function (node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n  };\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  };\n\n  var types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", true),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) {\n      return p.readTmplToken();\n    }),\n    f_expr: new TokContext(\"function\", true)\n  };\n  var pp$6 = Parser.prototype;\n\n  pp$6.initialContext = function () {\n    return [types.b_stat];\n  };\n\n  pp$6.braceIsBlock = function (prevType) {\n    if (prevType === tt.colon) {\n      var parent = this.curContext();\n      if (parent === types.b_stat || parent === types.b_expr) return !parent.isExpr;\n    }\n\n    if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR) return true;\n    if (prevType == tt.braceL) return this.curContext() === types.b_stat;\n    return !this.exprAllowed;\n  };\n\n  pp$6.updateContext = function (prevType) {\n    var update,\n        type = this.type;\n    if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;\n  }; // Token-specific context update code\n\n\n  tt.parenR.updateContext = tt.braceR.updateContext = function () {\n    if (this.context.length == 1) {\n      this.exprAllowed = true;\n      return;\n    }\n\n    var out = this.context.pop();\n\n    if (out === types.b_stat && this.curContext() === types.f_expr) {\n      this.context.pop();\n      this.exprAllowed = false;\n    } else if (out === types.b_tmpl) {\n      this.exprAllowed = true;\n    } else {\n      this.exprAllowed = !out.isExpr;\n    }\n  };\n\n  tt.braceL.updateContext = function (prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n  };\n\n  tt.dollarBraceL.updateContext = function () {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  tt.parenL.updateContext = function (prevType) {\n    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n  };\n\n  tt.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n  };\n\n  tt._function.updateContext = function (prevType) {\n    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else && !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);\n    this.exprAllowed = false;\n  };\n\n  tt.backQuote.updateContext = function () {\n    if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);\n    this.exprAllowed = false;\n  }; // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    if (p.options.ranges) this.range = [p.start, p.end];\n  }; // ## Tokenizer\n\n\n  var pp$7 = Parser.prototype; // Are we running under Rhino?\n\n  var isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"; // Move to the next token\n\n  pp$7.next = function () {\n    if (this.options.onToken) this.options.onToken(new Token(this));\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$7.getToken = function () {\n    this.next();\n    return new Token(this);\n  }; // If we're in an ES6 environment, make parsers iterable\n\n\n  if (typeof Symbol !== \"undefined\") pp$7[Symbol.iterator] = function () {\n    var self = this;\n    return {\n      next: function next() {\n        var token = self.getToken();\n        return {\n          done: token.type === tt.eof,\n          value: token\n        };\n      }\n    };\n  }; // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$7.setStrict = function (strict) {\n    var this$1 = this;\n    this.strict = strict;\n    if (this.type !== tt.num && this.type !== tt.string) return;\n    this.pos = this.start;\n\n    if (this.options.locations) {\n      while (this.pos < this.lineStart) {\n        this$1.lineStart = this$1.input.lastIndexOf(\"\\n\", this$1.lineStart - 2) + 1;\n        --this$1.curLine;\n      }\n    }\n\n    this.nextToken();\n  };\n\n  pp$7.curContext = function () {\n    return this.context[this.context.length - 1];\n  }; // Read a single token, updating the parser object's token-related\n  // properties.\n\n\n  pp$7.nextToken = function () {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.start = this.pos;\n    if (this.options.locations) this.startLoc = this.curPosition();\n    if (this.pos >= this.input.length) return this.finishToken(tt.eof);\n    if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());\n  };\n\n  pp$7.readToken = function (code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92\n    /* '\\' */\n    ) return this.readWord();\n    return this.getTokenFromCode(code);\n  };\n\n  pp$7.fullCharCodeAtPos = function () {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  pp$7.skipBlockComment = function () {\n    var this$1 = this;\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos,\n        end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n    this.pos = end + 2;\n\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this$1.curLine;\n        this$1.lineStart = match.index + match[0].length;\n      }\n    }\n\n    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n  };\n\n  pp$7.skipLineComment = function (startSkip) {\n    var this$1 = this;\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n\n    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++this$1.pos;\n      ch = this$1.input.charCodeAt(this$1.pos);\n    }\n\n    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n  }; // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n\n  pp$7.skipSpace = function () {\n    var this$1 = this;\n\n    loop: while (this.pos < this.input.length) {\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n          // ' '\n          ++this$1.pos;\n          break;\n\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n            ++this$1.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this$1.pos;\n\n          if (this$1.options.locations) {\n            ++this$1.curLine;\n            this$1.lineStart = this$1.pos;\n          }\n\n          break;\n\n        case 47:\n          // '/'\n          switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n            case 42:\n              // '*'\n              this$1.skipBlockComment();\n              break;\n\n            case 47:\n              this$1.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this$1.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }; // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n\n  pp$7.finishToken = function (type, val) {\n    this.end = this.pos;\n    if (this.options.locations) this.endLoc = this.curPosition();\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n  }; // ### Token reading\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  pp$7.readToken_dot = function () {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) return this.readNumber(true);\n    var next2 = this.input.charCodeAt(this.pos + 2);\n\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(tt.ellipsis);\n    } else {\n      ++this.pos;\n      return this.finishToken(tt.dot);\n    }\n  };\n\n  pp$7.readToken_slash = function () {\n    // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (this.exprAllowed) {\n      ++this.pos;\n      return this.readRegexp();\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.slash, 1);\n  };\n\n  pp$7.readToken_mult_modulo_exp = function (code) {\n    // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? tt.star : tt.modulo; // exponentiation operator ** and **=\n\n    if (this.options.ecmaVersion >= 7 && next === 42) {\n      ++size;\n      tokentype = tt.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, size + 1);\n    return this.finishOp(tokentype, size);\n  };\n\n  pp$7.readToken_pipe_amp = function (code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);\n  };\n\n  pp$7.readToken_caret = function () {\n    // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.bitwiseXOR, 1);\n  };\n\n  pp$7.readToken_plus_min = function (code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === code) {\n      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken();\n      }\n\n      return this.finishOp(tt.incDec, 2);\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.plusMin, 1);\n  };\n\n  pp$7.readToken_lt_gt = function (code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);\n      return this.finishOp(tt.bitShift, size);\n    }\n\n    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {\n      if (this.inModule) this.unexpected(); // `<!--`, an XML-style comment that should be interpreted as a line comment\n\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    if (next === 61) size = 2;\n    return this.finishOp(tt.relational, size);\n  };\n\n  pp$7.readToken_eq_excl = function (code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n      // '=>'\n      this.pos += 2;\n      return this.finishToken(tt.arrow);\n    }\n\n    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);\n  };\n\n  pp$7.getTokenFromCode = function (code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n      case 46:\n        // '.'\n        return this.readToken_dot();\n      // Punctuation tokens.\n\n      case 40:\n        ++this.pos;\n        return this.finishToken(tt.parenL);\n\n      case 41:\n        ++this.pos;\n        return this.finishToken(tt.parenR);\n\n      case 59:\n        ++this.pos;\n        return this.finishToken(tt.semi);\n\n      case 44:\n        ++this.pos;\n        return this.finishToken(tt.comma);\n\n      case 91:\n        ++this.pos;\n        return this.finishToken(tt.bracketL);\n\n      case 93:\n        ++this.pos;\n        return this.finishToken(tt.bracketR);\n\n      case 123:\n        ++this.pos;\n        return this.finishToken(tt.braceL);\n\n      case 125:\n        ++this.pos;\n        return this.finishToken(tt.braceR);\n\n      case 58:\n        ++this.pos;\n        return this.finishToken(tt.colon);\n\n      case 63:\n        ++this.pos;\n        return this.finishToken(tt.question);\n\n      case 96:\n        // '`'\n        if (this.options.ecmaVersion < 6) break;\n        ++this.pos;\n        return this.finishToken(tt.backQuote);\n\n      case 48:\n        // '0'\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n\n        if (this.options.ecmaVersion >= 6) {\n          if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n\n          if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n        }\n\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        // 1-9\n        return this.readNumber(false);\n      // Quotes produce strings.\n\n      case 34:\n      case 39:\n        // '\"', \"'\"\n        return this.readString(code);\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return this.readToken_slash();\n\n      case 37:\n      case 42:\n        // '%*'\n        return this.readToken_mult_modulo_exp(code);\n\n      case 124:\n      case 38:\n        // '|&'\n        return this.readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return this.readToken_caret();\n\n      case 43:\n      case 45:\n        // '+-'\n        return this.readToken_plus_min(code);\n\n      case 60:\n      case 62:\n        // '<>'\n        return this.readToken_lt_gt(code);\n\n      case 61:\n      case 33:\n        // '=!'\n        return this.readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return this.finishOp(tt.prefix, 1);\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp$7.finishOp = function (type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n  }; // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n\n  function tryCreateRegexp(src, flags, throwErrorAt, parser) {\n    try {\n      return new RegExp(src, flags);\n    } catch (e) {\n      if (throwErrorAt !== undefined) {\n        if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message);\n        throw e;\n      }\n    }\n  }\n\n  var regexpUnicodeSupport = !!tryCreateRegexp(\"\\uFFFF\", \"u\");\n\n  pp$7.readRegexp = function () {\n    var this$1 = this;\n    var escaped,\n        inClass,\n        start = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\");\n      var ch = this$1.input.charAt(this$1.pos);\n      if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\");\n\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n\n      ++this$1.pos;\n    }\n\n    var content = this.input.slice(start, this.pos);\n    ++this.pos; // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n\n    var mods = this.readWord1();\n    var tmp = content,\n        tmpFlags = \"\";\n\n    if (mods) {\n      var validFlags = /^[gim]*$/;\n      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;\n      if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n\n      if (mods.indexOf(\"u\") >= 0) {\n        if (regexpUnicodeSupport) {\n          tmpFlags = \"u\";\n        } else {\n          // Replace each astral symbol and every Unicode escape sequence that\n          // possibly represents an astral symbol or a paired surrogate with a\n          // single ASCII symbol to avoid throwing on regular expressions that\n          // are only valid in combination with the `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n          // be replaced by `[x-b]` which throws an error.\n          tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n            code = Number(\"0x\" + code);\n            if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\");\n            return \"x\";\n          });\n          tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n          tmpFlags = tmpFlags.replace(\"u\", \"\");\n        }\n      }\n    } // Detect invalid regular expressions.\n\n\n    var value = null; // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n    // so don't do detection if we are running under Rhino\n\n    if (!isRhino) {\n      tryCreateRegexp(tmp, tmpFlags, start, this); // Get a regular expression object for this pattern-flag pair, or `null` in\n      // case the current environment doesn't support the flags it uses.\n\n      value = tryCreateRegexp(content, mods);\n    }\n\n    return this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n      value: value\n    });\n  }; // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n\n  pp$7.readInt = function (radix, len) {\n    var this$1 = this;\n    var start = this.pos,\n        total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this$1.input.charCodeAt(this$1.pos),\n          val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n        else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n          else val = Infinity;\n      if (val >= radix) break;\n      ++this$1.pos;\n      total = total * radix + val;\n    }\n\n    if (this.pos === start || len != null && this.pos - start !== len) return null;\n    return total;\n  };\n\n  pp$7.readRadixNumber = function (radix) {\n    this.pos += 2; // 0x\n\n    var val = this.readInt(radix);\n    if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    return this.finishToken(tt.num, val);\n  }; // Read an integer, octal integer, or floating-point number.\n\n\n  pp$7.readNumber = function (startsWithDot) {\n    var start = this.pos,\n        isFloat = false,\n        octal = this.input.charCodeAt(this.pos) === 48;\n    if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    var next = this.input.charCodeAt(this.pos);\n\n    if (next === 46) {\n      // '.'\n      ++this.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.pos);\n    }\n\n    if (next === 69 || next === 101) {\n      // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) ++this.pos; // '+-'\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    var str = this.input.slice(start, this.pos),\n        val;\n    if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\");else val = parseInt(str, 8);\n    return this.finishToken(tt.num, val);\n  }; // Read a string value, interpreting backslash-escapes.\n\n\n  pp$7.readCodePoint = function () {\n    var ch = this.input.charCodeAt(this.pos),\n        code;\n\n    if (ch === 123) {\n      if (this.options.ecmaVersion < 6) this.unexpected();\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\");\n    } else {\n      code = this.readHexChar(4);\n    }\n\n    return code;\n  };\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n  }\n\n  pp$7.readString = function (quote) {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = ++this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\");\n      var ch = this$1.input.charCodeAt(this$1.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(false);\n        chunkStart = this$1.pos;\n      } else {\n        if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\");\n        ++this$1.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(tt.string, out);\n  }; // Reads template string tokens.\n\n\n  pp$7.readTmplToken = function () {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\");\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {\n        // '`', '${'\n        if (this$1.pos === this$1.start && this$1.type === tt.template) {\n          if (ch === 36) {\n            this$1.pos += 2;\n            return this$1.finishToken(tt.dollarBraceL);\n          } else {\n            ++this$1.pos;\n            return this$1.finishToken(tt.backQuote);\n          }\n        }\n\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        return this$1.finishToken(tt.template, out);\n      }\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(true);\n        chunkStart = this$1.pos;\n      } else if (isNewLine(ch)) {\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        ++this$1.pos;\n\n        switch (ch) {\n          case 13:\n            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos;\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        if (this$1.options.locations) {\n          ++this$1.curLine;\n          this$1.lineStart = this$1.pos;\n        }\n\n        chunkStart = this$1.pos;\n      } else {\n        ++this$1.pos;\n      }\n    }\n  }; // Used to read escaped characters\n\n\n  pp$7.readEscapedChar = function (inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n      // 'n' -> '\\n'\n\n      case 114:\n        return \"\\r\";\n      // 'r' -> '\\r'\n\n      case 120:\n        return String.fromCharCode(this.readHexChar(2));\n      // 'x'\n\n      case 117:\n        return codePointToString(this.readCodePoint());\n      // 'u'\n\n      case 116:\n        return \"\\t\";\n      // 't' -> '\\t'\n\n      case 98:\n        return \"\\b\";\n      // 'b' -> '\\b'\n\n      case 118:\n        return \"\\x0B\";\n      // 'v' -> '\\u000b'\n\n      case 102:\n        return \"\\f\";\n      // 'f' -> '\\f'\n\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n      // '\\r\\n'\n\n      case 10:\n        // ' \\n'\n        if (this.options.locations) {\n          this.lineStart = this.pos;\n          ++this.curLine;\n        }\n\n        return \"\";\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n            this.raise(this.pos - 2, \"Octal literal in strict mode\");\n          }\n\n          this.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }; // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\n  pp$7.readHexChar = function (len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) this.raise(codePos, \"Bad character escape sequence\");\n    return n;\n  }; // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n\n  pp$7.readWord1 = function () {\n    var this$1 = this;\n    this.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n\n    while (this.pos < this.input.length) {\n      var ch = this$1.fullCharCodeAtPos();\n\n      if (isIdentifierChar(ch, astral)) {\n        this$1.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this$1.containsEsc = true;\n        word += this$1.input.slice(chunkStart, this$1.pos);\n        var escStart = this$1.pos;\n        if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n          this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++this$1.pos;\n        var esc = this$1.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this$1.raise(escStart, \"Invalid Unicode escape\");\n        word += codePointToString(esc);\n        chunkStart = this$1.pos;\n      } else {\n        break;\n      }\n\n      first = false;\n    }\n\n    return word + this.input.slice(chunkStart, this.pos);\n  }; // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n\n  pp$7.readWord = function () {\n    var word = this.readWord1();\n    var type = tt.name;\n    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = keywordTypes[word];\n    return this.finishToken(type, word);\n  };\n\n  var version = \"3.3.0\"; // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return new Parser(options, input).parse();\n  } // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n\n  function parseExpressionAt(input, pos, options) {\n    var p = new Parser(options, input, pos);\n    p.nextToken();\n    return p.parseExpression();\n  } // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n\n  function tokenizer(input, options) {\n    return new Parser(options, input);\n  }\n\n  exports.version = version;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokenizer = tokenizer;\n  exports.Parser = Parser;\n  exports.plugins = plugins;\n  exports.defaultOptions = defaultOptions;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.getLineInfo = getLineInfo;\n  exports.Node = Node;\n  exports.TokenType = TokenType;\n  exports.tokTypes = tt;\n  exports.TokContext = TokContext;\n  exports.tokContexts = types;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.Token = Token;\n  exports.isNewLine = isNewLine;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}