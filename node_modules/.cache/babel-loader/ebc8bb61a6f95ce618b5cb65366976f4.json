{"ast":null,"code":"'use strict';\n\nvar detect = require('acorn-globals');\n\nvar acorn = require('acorn');\n\nvar walk = require('acorn/dist/walk'); // hacky fix for https://github.com/marijnh/acorn/issues/227\n\n\nfunction reallyParse(source) {\n  return acorn.parse(source, {\n    ecmaVersion: 6,\n    allowReturnOutsideFunction: true\n  });\n}\n\nmodule.exports = addWith;\n/**\n * Mimic `with` as far as possible but at compile time\n *\n * @param {String} obj The object part of a with expression\n * @param {String} src The body of the with expression\n * @param {Array.<String>} exclude A list of variable names to explicitly exclude\n */\n\nfunction addWith(obj, src, exclude) {\n  obj = obj + '';\n  src = src + '';\n  exclude = exclude || [];\n  exclude = exclude.concat(detect(obj).map(function (global) {\n    return global.name;\n  }));\n  var vars = detect(src).map(function (global) {\n    return global.name;\n  }).filter(function (v) {\n    return exclude.indexOf(v) === -1 && v !== 'undefined' && v !== 'this';\n  });\n  if (vars.length === 0) return src;\n  var declareLocal = '';\n  var local = 'locals_for_with';\n  var result = 'result_of_with';\n\n  if (/^[a-zA-Z0-9$_]+$/.test(obj)) {\n    local = obj;\n  } else {\n    while (vars.indexOf(local) != -1 || exclude.indexOf(local) != -1) {\n      local += '_';\n    }\n\n    declareLocal = 'var ' + local + ' = (' + obj + ')';\n  }\n\n  while (vars.indexOf(result) != -1 || exclude.indexOf(result) != -1) {\n    result += '_';\n  }\n\n  var inputVars = vars.map(function (v) {\n    return JSON.stringify(v) + ' in ' + local + '?' + local + '.' + v + ':' + 'typeof ' + v + '!==\"undefined\"?' + v + ':undefined';\n  });\n  src = '(function (' + vars.join(', ') + ') {' + src + '}.call(this' + inputVars.map(function (v) {\n    return ',' + v;\n  }).join('') + '))';\n  return ';' + declareLocal + ';' + unwrapReturns(src, result) + ';';\n}\n/**\n * Take a self calling function, and unwrap it such that return inside the function\n * results in return outside the function\n *\n * @param {String} src    Some JavaScript code representing a self-calling function\n * @param {String} result A temporary variable to store the result in\n */\n\n\nfunction unwrapReturns(src, result) {\n  var originalSource = src;\n  var hasReturn = false;\n  var ast = reallyParse(src);\n  var ref;\n  src = src.split(''); // get a reference to the function that was inserted to add an inner context\n\n  if ((ref = ast.body).length !== 1 || (ref = ref[0]).type !== 'ExpressionStatement' || (ref = ref.expression).type !== 'CallExpression' || (ref = ref.callee).type !== 'MemberExpression' || ref.computed !== false || ref.property.name !== 'call' || (ref = ref.object).type !== 'FunctionExpression') throw new Error('AST does not seem to represent a self-calling function');\n  var fn = ref;\n  walk.recursive(ast, null, {\n    Function: function Function(node, st, c) {\n      if (node === fn) {\n        c(node.body, st, \"ScopeBody\");\n      }\n    },\n    ReturnStatement: function ReturnStatement(node) {\n      hasReturn = true;\n      replace(node, 'return {value: (' + (node.argument ? source(node.argument) : 'undefined') + ')};');\n    }\n  });\n\n  function source(node) {\n    return src.slice(node.start, node.end).join('');\n  }\n\n  function replace(node, str) {\n    for (var i = node.start; i < node.end; i++) {\n      src[i] = '';\n    }\n\n    src[node.start] = str;\n  }\n\n  if (!hasReturn) return originalSource;else return 'var ' + result + '=' + src.join('') + ';if (' + result + ') return ' + result + '.value';\n}","map":null,"metadata":{},"sourceType":"script"}